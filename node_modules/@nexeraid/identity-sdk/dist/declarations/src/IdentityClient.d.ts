import type { z } from "zod";
import type { BlockchainSignature } from "@nexeraprotocol/identity-schemas";
import { BlockchainAddress } from "@nexeraprotocol/identity-schemas";
import type { Address, Environment } from "@nexeraprotocol/identity-schemas/";
import type { GetCredentialsRequest, GetTxAuthDataSignatureResponse, PolygonIdRequestData, TransactionData, TxAuthInput } from "@nexeraprotocol/identity-schemas/identity";
import { KycCompletionData, ScenarioExecutionData } from "@nexeraprotocol/identity-schemas/identity";
import type { IdentityAuthenticationInputs, IIdentityClient } from "./types/client.js";
export * from "./types/client.js";
export * from "./types/actions.js";
/**
 * Build a signature message for generating a seed.
 * @param address - The wallet address to include in the message.
 * @returns The signature message as a string.
 */
export declare const buildSignatureMessage: (address: BlockchainAddress) => string;
/**
 * Represents the configuration object for the IdentityClient.
 */
export type IdentityClientConfig = {
    /**
     * Optional environment setting for the IdentityClient.
     * @see {@link Environment} for available options.
     */
    env: Environment;
};
export declare class IdentityClient implements IIdentityClient {
    polygonIdDID?: string;
    private readonly baseURL;
    private identifier?;
    private callbacks;
    private iframe?;
    private iframeName?;
    private flowInProgress;
    private initDataSent;
    private startCompleted;
    private polygonWalletReady;
    private did;
    private ocvSdkReady;
    /**
     * Constructs a new IdentityClient object.
     * @param config - Optional configuration object for the IdentityClient.
     * See {@link IdentityClientConfig}  for further details.
     * If `env` is not defined, prod is used as default, using <https://identity.nexera.id> as Nexera KYC app
     */
    constructor(config?: IdentityClientConfig);
    /**
     * Callback function. Called when a message needs to be signed.
     *
     * This needs to be registered by the integrator. It requires a function that will provide a signature from the connected wallet.
     *
     * @example
     * IDENTITY_CLIENT.onSignMessage(async (data: { message: string }) => {
     *   return await signMessageAsync({ message: data.message });
     * });
  
     * @param signMessageCallback
     */
    onSignMessage: (signMessageCallback: (data: {
        message: string;
    }) => Promise<BlockchainSignature>) => void;
    /**
     * Callback function. Used to sign transactions on the on-chain ZKP allowlist system.
     *
     * The ZKPs and associated transaction data is prepared in the identity app by making a call to the API to get the ZKPrequests and creating the ZKP using the PolygonID Wallet.
     *
     * Then, the transaction is signed and sent using this callback. to be registered by client to send transaction.
     *
     * @example
     * import { useWalletClient } from 'wagmi';
     * IDENTITY_CLIENT.onSendTransaction(async (data: TransactionData) => {
     *   return walletClient.sendTransaction({
     *     account: data.accountAddress,
     *     to: data.to,
     *     data: data.data,
     *     value: data.value ? parseEther(data.value) : parseEther("0"),
     *   });
     * });
     * @param sendTransactionCallback (data: TransactionData) => Promise<txHash: string>
     */
    onSendTransaction: (sendTransactionCallback: (data: TransactionData) => Promise<`0x${string}` | undefined>) => void;
    /**
     * @ignore
     * Callback function.  Called when a kyc process is completed and data is sent to the registered webhook.
     * @param kycCompletionCallback
     */
    onKycCompletion: (kycCompletionCallback: (data: z.infer<typeof KycCompletionData>) => void) => void;
    /**
     * Callback function. Called when a scenario is executed by the NexeraID Rules Engine.
     *
     * @example
     * IDENTITY_CLIENT.onScenarioExecution(
     *   (data) => {}
     * );
     * @param onScenarioExecutionCallback
     */
    onScenarioExecution: (onScenarioExecutionCallback: (data: ScenarioExecutionData) => void) => void;
    /**
     * Callback function. Called when the identity modal is closed.
     *
     * @example
     * public onCloseScreen = (
     *   onCloseScreenCallback: () => Promise<string>) => {
     *     this.callbacks.closeScreenCallback = onCloseScreenCallback;
     *   };
     * )
     * @param onCloseScreenCallback
     */
    onCloseScreen: (onCloseScreenCallback: () => Promise<string>) => void;
    /**
     * Callback function. Called when the SDK is ready. `onSdkReady` means that the Polygon ID wallet is ready and the blockchain client and SDK are set up.
     *
     * This must be emitted _before_ you use `init`.
     *
     * @example
     * IDENTITY_CLIENT.onSdkReady((data) => {
     *   setDID(data.did);
     * });
     *
     * @param onSdkReadyCallback
     */
    onSdkReady: (onSdkReadyCallback: (data: {
        did: string;
    }) => void) => void;
    /**
     * Callback function. Called when any type of verification happens (ZKP or NexeraID Rules Engine).
     *
     * @example
     * IDENTITY_CLIENT.onVerification((isVerified) => {
     *    setVerified(isVerified);
     * });
  
     * @param onVerification
     */
    onVerification: (onVerification: (isVerified: boolean) => void) => void;
    /**
     * The `init` method receives the authorization inputs. It must be called before any flow starts.
     *
     * There are several callbacks that can be used to integrate with the SDK lifecycle. They are [`onSignMessage`](#onsignmessage), [`onSendTransaction`](#onsendtransaction), [`onSdkReady`](#onsdkready), [`onVerification`](#onverification), and [`onScenarioExecution`](#onscenarioexecution).
     *
     * Ideally, these should all be registered before calling `init`.
     *
     * | Argument         | Description                                                           | Required |
     * |------------------|-----------------------------------------------------------------------|----------|
     * | `accessToken`    | The access token from your back end server                            | Yes      |
     * | `signature`      | Signature                                                             | Yes      |
     * | `signingMessage` | Signing message, used to store the KYC data in the customer's browser | Yes      |
     *
     * For some examples, see [`init` examples](../init.md).
     *
     * @param authenticationInputs
     */
    init: (authenticationInputs: IdentityAuthenticationInputs) => Promise<void>;
    /**
     * Starts a verification flow.
     *
     * After [`onSdkReady`](#onsdkready) is emitted, you can start the verification flow using the `startVerification` method. It does have any arguments.
     * :::tip
     * `onSdkReady` means that the Polygon ID wallet is ready and the blockchain client and SDK are set up.
     * :::
     *
     * When flow is completed, a response is sent to the webhooks.
     *
     * After the flow is completed, you should tell the customer of your decision and proceed with the transaction if appropriate.
     *
     * See [line 32](https://github.com/NexeraProtocol/nexeraid-examples/blob/d12cf5ce8ed992cd8e5527edab59964c23041a33/example-apps/src/features/gated-nfts/gated-nfts/identity/IdentityFlow.tsx#L32) and [line 73](https://github.com/NexeraProtocol/nexeraid-examples/blob/d12cf5ce8ed992cd8e5527edab59964c23041a33/example-apps/src/features/gated-nfts/gated-nfts/identity/IdentityFlow.tsx#L73) in [`IdentityFlow.tsx`](https://github.com/NexeraProtocol/nexeraid-examples/blob/d12cf5ce8ed992cd8e5527edab59964c23041a33/example-apps/src/features/gated-nfts/gated-nfts/identity/IdentityFlow.tsx) for examples.
     *
     * @example
     * // This code should be in a hook.
     * IDENTITY_CLIENT.onSdkReady((data) => {
     *   setDID(data.did);
     * });
     *
     * @example
     * // This code should be in the return statement of a react component.
     * <Button
     *   id="example-kyc-verify-link-button"
     *   onClick={() => {
     *     IDENTITY_CLIENT.startVerification();
     *     close();
     *   }}
     *   disabled={!did}
     * >
     * Verify
     * </Button>;
     */
    startVerification: () => void;
    /**
     * @ignore
     * Starts a management flow.
     * The iframe is revealed with management components
     * Requires init to be run before
     */
    startManagement: () => void;
    /**
     * Starts a KYB flow.
     *
     * After [`onSdkReady`](#onsdkready) is emitted, you can start the KYB flow using the `startKYB` method. It does have any arguments.
     *
     * :::tip
     * `onSdkReady` means that the Polygon ID wallet is ready and the blockchain client and SDK are set up.
     * :::
     *
     * When flow is completed, a response is sent to the webhooks.
     *
     * After the flow is completed, you should tell the customer of your decision and proceed with the transaction if appropriate.
     *
     * @example
     * //This code should be in a hook.
     * IDENTITY_CLIENT.onSdkReady((data) => {
     *   setDID(data.did);
     * });
     *
     * @example
     * // This code should be in the return statement of a react component.
     * <Button
     *   id="example-kyc-verify-link-button"
     *   onClick={() => {
     *     IDENTITY_CLIENT.startKYB();
     *   }}
     *   disabled={!did}
     * >
     * Verify
     * </Button>;
     */
    startKYB: () => void;
    /**
     * Closes the Identity SDK.
     *
     * @example
     * IDENTITY_CLIENT.close();
     */
    close: () => void;
    /**
     *
     * Starts a PolygonId protocol flow.
     *
     * Supports:
     *
     * - auth handles `AuthorizationRequestMessage` :
     * generates a zk-request for the given inputs and
     * automatically calls verify endpoint
     * with zk-proof generated with the wallet
     * - credentialOffer handles CredentialOffer object in string format
     * adds a credential to the polygon wallet (sent from a third party)
     * - credentialRequest `ZeroKnowledgeProofRequest`:
     * generates a zk-request for the given inputs
     *
     * | Argument     | Required | Description                                              |
     * |--------------|----------|----------------------------------------------------------|
     * | `type`       | Yes      | Request type; can be `auth`, `zkp`, or `credentialOffer` |
     * | `zkpRequest` | No       | Set to `zkpRequest` when `type` is `zkp`                 |
     *
     * :::note
     * The examples follow the [Iden3comm standard](https://0xpolygonid.github.io/tutorials/wallet/wallet-sdk/polygonid-sdk/iden3comm/overview/).
     * :::
     * @example
     *
     * // generates a zero-knowledge request for the given inputs and automatically
     * // calls the verify endpoint with the zero-knowledge proof generated by the wallet.
     *
     * import type { AuthorizationRequestMessage } from "@nexeraprotocol/nexera-id-schemas";
     * const authRequest: AuthorizationRequestMessage = {...}
     * await IDENTITY_CLIENT.polygonIdRequest(
     *   { type: "auth", authRequest}
     * );
     *
     * @example
     * // Generates a zero-knowledge request for the given inputs.
     *
     * import type { ZeroKnowledgeProofRequest } from "@nexeraprotocol/nexera-id-schemas";
     * const zkpRequest: ZeroKnowledgeProofRequest = {...}
     * await IDENTITY_CLIENT.polygonIdRequest(
     *   { type: "zkp", zkpRequest: zkpRequest }
     * );
     *
     * @example
     * //Handles a CredentialOffer object in string format. It adds a credential, sent from a third party, to the Polygon ID wallet.
     *
     * const authRequest:string="{...}"
     * await IDENTITY_CLIENT.polygonIdRequest(
     *   { type: "credentialOffer", credentialOfferRequest }
     * );
     *
     * @param data
     */
    polygonIdRequest: (data: PolygonIdRequestData) => Promise<unknown>;
    /**
     * Returns the stored credentials of the connected wallet.
     *
     * | Argument | Required | Description                    |
     * |----------|----------|--------------------------------|
     * | `type`   | Yes      | Always set to `getCredentials` |
     * | `data`   | Yes      | Always set to `undefined`      |
     *
     * @example
     * const credentials = await IDENTITY_CLIENT.getStoredCredentials(
     *   { type: "getCredentials", data: undefined }, // data will be able to add filters later
     * );
     *
     * @param props
     */
    getStoredCredentials: (props: GetCredentialsRequest) => Promise<{
        id: string;
        journeyId: string;
        type: string[];
        issuanceDate: string;
    }[]>;
    /**
     * @ignore
     * Returns true if a user address is whitelisted.
     * @param userAddress
     */
    isUserAllowedForEntrypoint: (userAddress: Address) => Promise<boolean>;
    /**
     * Used to retrieve a signature from the Nexera API to authorize a contract call gated with the `TxAuthDataSignature` smart contract gating.
     *
     * It returns a `signatureResponse` object that has three properties:
     *
     * - `isAuthorized`: boolean. True if this customer is authorized.
     * - `blockExpiration`: the block number after which the request is considered expired.
     * - `signature`: the signature.
     *
     * By default, `blockExpiration` is 50 greater than the latest block, giving the signature a validity of 50 blocks. If you want to change this (for security or convenience, for example) you can set an explicit value for `blockExpiration`, as shown in the example below.
     *
     * `getTxAuthSignature` has one argument, a `txAuthInput` object with the following properties.
     *
     * | Property          | Description                                                          |
     * |-------------------|----------------------------------------------------------------------|
     * | `contractAbi`     | The ABI for the gated smart contract                                 |
     * | `contractAddress` | The address of the gated smart contract                              |
     * | `functionName`    | The name of the function in the gated smart contract                 |
     * | `args`            | An array containing the input for the function                       |
     * | `chainId`         | The ID of the chain that the tx will be posted on                    |
     * | `blockExpiration` | Block number after which the request is considered expired; optional |
     *
     * @example
     * // optional blockExpiration
     * const blockExpiration = Number((await txAuthWalletClient.getBlock({ blockTag: "latest" })).number) +100;
     *
     * // get chain ID from client
     * const chainId = await client.getChainId();
     *
     * // Tx Auth Input
     * // with our example Gated NFT Minter
     * const txAuthInput = {
     *   contractAbi: ExampleGatedNFTMinterABI,
     *   contractAddress: ExampleGatedNFTMinterAddress,
     *   functionName: "mintNFTGated",
     *   args: [recipientAddress],
     *   blockExpiration,
     *   chainId
     * };
     *
     * // Get signature Response
     * const signatureResponse: GetTxAuthDataSignatureResponse = await IDENTITY_CLIENT.getTxAuthSignature(
     *   txAuthInput
     * );
     *
     * @param input
     */
    getTxAuthSignature: (input: Omit<TxAuthInput, "userAddress">) => Promise<GetTxAuthDataSignatureResponse>;
    private _waitForStartCompleted;
    /**
     * Private method to initialize the iframe (hidden) with kyc-app and start event listening.
     * That way, third party apps can communicate with kyc-app.
     * To display the frame, use startVerification or startManagement
     * It performs necessary checks, sets the flow in progress, and opens a session.
     * signPersonalData callback is needed for initializing flow.
     *
     * @param authenticationInputs - Authentication inputs required to start the flow.
     */
    private _startFlow;
    /**
     * Sends message to the kyc-app iframe.
     * @param message
     */
    private _sendMessageToIdentityApp;
    private _initEvents;
    private _openSession;
    private _setIframeAttributes;
    private _closeFlow;
}
//# sourceMappingURL=IdentityClient.d.ts.map