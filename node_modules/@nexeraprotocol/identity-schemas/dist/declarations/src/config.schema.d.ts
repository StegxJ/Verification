import { z } from "zod";
/**
 * EIP155
 */
export declare const isValidAddress: (address: string) => boolean;
declare const String0x: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
type String0x = z.infer<typeof String0x>;
export type TxData = PrivateKey;
export declare const PrivateKey: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type PrivateKey = String0x;
/**
 * Note: it might be nice to use String0x as the base object instead of z.string(),
 * but this causes update-api to fail with the following error:
 * TRPCError: [query.kyc.sumsub.getJourneyData] -
 * Input parser key: "userAddress" must be ZodString, ZodNumber, ZodBoolean, ZodBigInt or ZodDate
 */
export declare const AddressSchema: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type Address = z.infer<typeof AddressSchema>;
export declare const TxHash: z.ZodEffects<z.ZodString, `0x${string}`, string>;
export type TxHash = z.infer<typeof TxHash>;
export declare const EIP155Signature: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type EIP155Signature = String0x;
export declare const FunctionCallData: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type FunctionCallData = String0x;
export declare const shortAddress: (address: BlockchainAddress) => string;
/**
 * Aptos
 */
export declare const AptosAddress: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type AptosAddress = z.infer<typeof AptosAddress>;
export declare const AptosSignature: z.ZodString;
export type AptosSignature = z.infer<typeof AptosSignature>;
/**
 * Starknet
 */
export declare const StarknetAddress: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type StarknetAddress = z.infer<typeof StarknetAddress>;
export declare const StarknetSignature: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type StarknetSignature = z.infer<typeof StarknetSignature>;
/**
 * Polkadot
 */
export declare const PolkadotAddress: z.ZodString;
export type PolkadotAddress = z.infer<typeof PolkadotAddress>;
export declare const PolkadotSignature: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>;
export type PolkadotSignature = z.infer<typeof PolkadotSignature>;
/**
 * Cosmos
 */
export declare const CosmosAddress: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `cosmos${string}`, string>;
export type CosmosAddress = z.infer<typeof CosmosAddress>;
export declare const CosmosSignature: z.ZodEffects<z.ZodString, string, string>;
export type CosmosSignature = z.infer<typeof CosmosSignature>;
/**
 * Tezos
 */
export declare const TezosAddress: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `tz${string}`, string>;
export type TezosAddress = z.infer<typeof TezosAddress>;
export declare const EdSignature: z.ZodEffects<z.ZodString, `edsig${string}`, string>;
export type EdSignature = z.infer<typeof EdSignature>;
export declare const SpSignature: z.ZodEffects<z.ZodString, `spsig${string}`, string>;
export type SpSignature = z.infer<typeof SpSignature>;
export declare const P2Signature: z.ZodEffects<z.ZodString, `p2sig${string}`, string>;
export type P2Signature = z.infer<typeof P2Signature>;
export declare const TezosSignature: z.ZodUnion<[z.ZodEffects<z.ZodString, `edsig${string}`, string>, z.ZodEffects<z.ZodString, `spsig${string}`, string>, z.ZodEffects<z.ZodString, `p2sig${string}`, string>]>;
export type TezosSignature = z.infer<typeof TezosSignature>;
/**
 * Cardano
 */
export declare const CardanoAddress: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `addr${string}`, string>;
export type CardanoAddress = z.infer<typeof CardanoAddress>;
export declare const CardanoSignature: z.ZodEffects<z.ZodString, string, string>;
export type CardanoSignature = z.infer<typeof CardanoSignature>;
/**
 * Chain agnostic schemas
 */
export declare const BlockchainAddress: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `tz${string}`, string>, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `cosmos${string}`, string>, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `addr${string}`, string>]>;
export type BlockchainAddress = z.infer<typeof BlockchainAddress>;
export declare const BlockchainSignature: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodUnion<[z.ZodEffects<z.ZodString, `edsig${string}`, string>, z.ZodEffects<z.ZodString, `spsig${string}`, string>, z.ZodEffects<z.ZodString, `p2sig${string}`, string>]>, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, `0x${string}`, string>, z.ZodEffects<z.ZodString, string, string>, z.ZodEffects<z.ZodString, string, string>]>;
export type BlockchainSignature = z.infer<typeof BlockchainSignature>;
export declare const BLOCKCHAIN_NAMESPACES: readonly ["tezos", "eip155", "aptos", "polkadot", "starknet", "cosmos", "solana", "cardano"];
export declare const BlockchainNamespace: z.ZodEnum<["tezos", "eip155", "aptos", "polkadot", "starknet", "cosmos", "solana", "cardano"]>;
export type BlockchainNamespace = z.infer<typeof BlockchainNamespace>;
export declare const coerceBoolean: z.ZodEffects<z.ZodCatch<z.ZodEnum<["0", "1", "true", "false"]>>, boolean, unknown>;
export declare const ENVS: readonly ["cicd", "local", "test-dev-1", "test-dev-2", "dev", "stage", "prod"];
export declare const EnvironmentSchema: z.ZodEnum<["cicd", "local", "test-dev-1", "test-dev-2", "dev", "stage", "prod"]>;
export type Environment = z.infer<typeof EnvironmentSchema>;
export declare const UuidString: z.ZodString;
export type UuidString = z.infer<typeof UuidString>;
/**
 * Zod parse without throwing an error if the value is invalid
 * Rather, it returns a object with optional error and data fields
 *
 * @param schema
 * @param value
 * @constructor
 */
export declare function ZodParse<T>(schema: z.ZodSchema<T>, value: unknown): {
    data: z.infer<typeof schema>;
    error: undefined;
} | {
    error: z.ZodError<unknown>;
    data: undefined;
};
export declare const shortBlockchainAddress: (address: BlockchainAddress) => string;
export {};
//# sourceMappingURL=config.schema.d.ts.map